/*
 * 要将一个正数数组分成二个和相同的数组，显然愿数组的和必须是偶数。
 *
 * 然后，比较容易想到的是我们只要考虑：能否从原数组中挑出一些数，使得它们的和正好=half。 这就是背包问题了！！！
 *
 * 实际实现中，每个元素有两种状态：放入或不放入背包中，对于长度为n的数组，共有2^n的惊人状态需要考虑。
 *
 * 最简单的背包（每种物品都无限供应）的状态转移方程最简单：dp[remain] = max(value(i) + dp[remain - value(i)]), for i属于I
 *
 * 但本题中每个位置上的元素只有一个，这是典型的“0-1”背包问题！！！
 * 很容易让人陷入的困境是：定义状态时，除了背包剩余容量外，极容易纠结于，不同种数字的个数也考虑进状态（比如：1还剩多少个，5还剩多少个，99还剩多少个）,
 * 这样去定义状态，会发现状态的维度太大了……
 *
 * 我在状态这里卡了一天多T_T，实际上在容量remain之外，还需要数组index来表达： 剩余容量为remain，剩余数组为 num[i ... n]的子问题，即 dp[remain][index]
 *
 *
 * =================================================================
 * 我定义dp二维数组的行列和官方题解中的正好相反。
 * 1) 可以不用递归方式写；
 * 2) 另外，本题的空间复杂度可以再优化: O(n * half) -> O(half)
 * =================================================================
 */
#include <iostream>
#include <vector>
#include <map>

using std::map;
using std::vector;
using Mat = vector<vector<int>>;

class Solution {
public:
    bool canPartition(vector<int>& nums) {
		vector<int> sufSum(nums.size(), 0);
		sufSum.back() = nums.back();
		for (int i = nums.size() - 2; i >= 0; --i) {
			sufSum[i] = sufSum[i+1] + nums[i];
		}

		if ((sufSum[0] & 1) == 1) {
			// odd sum, can never be evenly partitioned
			return false;
		}

		int half = sufSum[0] / 2;  // 原问题平分数组 转化成 0-1背包问题，背包大小=half，背包需要装满!!!

		Mat dp(half+1, vector<int>(1+nums.size(), 0));  // 行为remain的数；列则为愿数组的序列。half+1，保证half可索引；1+nums.size()处理数组跑完的清形，这样比较好统一处理边界情况

		dp[0][nums.size()] = 1; // remain=0, 并且序列也用完了，成功！
		for (int j = 0; j < nums.size(); ++j) {   // 不考虑最后一列边界状态
			dp[0][j] = 1;   // remain = 0时，意味着成功
			for (int i = sufSum[j]+1; i <= half; ++i) {
				// remain > sufSum[i]，用于提前减枝，i（包含i）之后的总和都满足不了remain了，那肯定无法成功了
				dp[i][j] = -1;
			}
		}
		// 最后一列边界状态
		//最后一列是超出原数组大小的，这时候remain还没有装满，那肯定无法成功了
		for (int i = 1; i <= half; ++i) {
			dp[i][nums.size()] = -1;  
		}
		return split(half, 0, nums, dp) > 0;
    }

	int split(int remain, int i, vector<int>& nums, Mat& dp) {
		/* 我在上面做了非常多的边界定义工作，否则，这里定义dp的初始化状态也是ok的
		if (remain == 0) {
			return 1;
		} else if (remain < 0) {
			return -1;
		}
		if (i >= nums.size()) {
			return -1;
		}
		*/
		if (remain < 0) {
			return -1;
		}

		if (dp[remain][i] != 0) {
			return dp[remain][i];
		}
		dp[remain][i] = std::max(split(remain, i+1, nums, dp), split(remain - nums[i], i+1, nums, dp));
		return dp[remain][i];
	}
};

int main() {
	Solution sol;
	vector<int> nums = {1,5,11,5};
	//vector<int> nums = {1,5,5,9};
	//vector<int> nums = {1,2,5};
	//vector<int> nums = {1,2,3, 5};
	//vector<int> nums = {100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,99,97};
	//vector<int> nums = {1, 1, 1, 1};
	//vector<int> nums = {4,4,4,4,4,4,4,4,8,8,8,8,8,8,8,8,12,12,12,12,12,12,12,12,16,16,16,16,16,16,16,16,20,20,20,20,20,20,20,20,24,24,24,24,24,24,24,24,28,28,28,28,28,28,28,28,32,32,32,32,32,32,32,32,36,36,36,36,36,36,36,36,40,40,40,40,40,40,40,40,44,44,44,44,44,44,44,44,48,48,48,48,48,48,48,48,52,52,52,52,52,52,52,52,56,56,56,56,56,56,56,56,60,60,60,60,60,60,60,60,64,64,64,64,64,64,64,64,68,68,68,68,68,68,68,68,72,72,72,72,72,72,72,72,76,76,76,76,76,76,76,76,80,80,80,80,80,80,80,80,84,84,84,84,84,84,84,84,88,88,88,88,88,88,88,88,92,92,92,92,92,92,92,92,96,96,96,96,96,96,96,96,97,99};
	if (sol.canPartition(nums)) {
		std::cout << "Yes! nums can equally partitioned.\n";
	}
	return 0;
}
